# -*- coding: utf-8 -*-
"""Bank_customer_churn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O6MPO89LZFpn9QgFvcu-LiOAcm8hdWeN

# Bank Customer Churn Prediction

- kresnaandika36@gmail.com
- github.com/kresnandika

**This code is all my own with some references, feel free to use it**

---


# Introduction

A manager at a local bank is disturbed with more and more customers leaving their credit card services. They need a way of predicting which customers are most likely to stop using their credit card products (Customer Churn) in order to proactively check in on the customer to provide them better services in order to convince them to change their minds. You are given a dataset of 10,000 customers with 18 features per customer. Roughly 16% of the current customer base have churned so far, so it will be difficult to predict the ones who will.

As you analyze the data, before you create the model, the sales team also needs you to determine the most influential factors that can lead to a customer's decision of leaving the business. The head of the sales department is expecting a report that helps them visualize where the differences lie between churning and non-churning customers.

# Business Understanding

To define the success of the solution that we will deliver let's define the metrics as: F1 Score, Precision and Recall. This metrics were chosen since normally churn problems are imbalanced, but all depends on the definition of churn and the cost driven by each scenario.

## Objective


1. Identify which customers are most likely to be churned so the bank manager knows who to provide a better service to
  - The Top Priority is to identify churning customers,as if we predict non-churning customers as churned, it won't harm our business, but predicting churning customers as Non-churning will. False negatives won't hurt us, but False Positives do
  - This task is binary classification
2. A clean and easy to understand visual report that helps the sales team better visualize what makes a client churn or not churn
3. Precision and Recall Curves as well as the Confusion Matrix will also be used

## Goals

- consists of an exploratory analysis, where the objective is to know the behavior of the variables and to analyze attributes that indicate a strong relationship with the cancellation of credit card service customers.
- Performance of the model will be measured with accuracy and the rate of False Positives. The manager is looking for at least a 85% F1 Score accuracy
- identify customers who are getting churned. Even if we predict non-churning customers as churned, it won't harm our business. But predicting churning customers as Non-churning will do

## Problem Statements/issues

since only 16% of the customers are churned, a data upsampling method is needed to match them with the regular customer size to give our model a better chance of catching small details that would be missed had we not upsampled it

## Solution Statements

After we solve the issues, we will use some modeling in machine learning before we use deep neural net

- RandomForestClassifier : A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.
- KNeighborsClassifier : is a type of classification where the function is only approximated locally and all computation is deferred until function evaluation. Since this algorithm relies on distance for classification, if the features represent different physical units or come in vastly different scales then normalizing the training data can improve its accuracy dramatically
- SVC : are supervised learning models with associated learning algorithms that analyze data for classification and regression analysis.
- xgb : is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework.

# Data Understanding

The Backend Engineer at the bank gives us the data through their MySQL database in an easy to use CSV with all missing features replaced by an "unkown" string. However, he tried to train a Naive Bayes classifier and accidently left in 2 prediction columns in the data. No Worries. We'll also remove the Clientnumber as this isn't important

Source Dataset : [Credit Card customers](https://www.kaggle.com/sakshigoyal7/credit-card-customers/code)

## Getting the Data
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

from google.colab import drive

drive.mount('/content/drive/')

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

data = pd.read_csv('/content/drive/MyDrive/datasets/BankChurners.csv')
data.head()

data = data.drop('Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1',1)
data = data.drop('Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2', 1)
data = data.drop('CLIENTNUM', 1)

round((data.isnull().sum() * 100)/(data.shape[0]),2)

# Checking the Descriptive statistics of the numerical columns (Hidden Input)

data.describe().T.style.bar(
    subset=['mean'],
    color='lightsalmon').background_gradient(
    subset=['std'], cmap='plasma').background_gradient(subset=['75%'], cmap='plasma').background_gradient(
    subset=['max'], cmap='plasma')

"""## Feature Description


- CLIENTNUM: Client number. Unique identifier for the customer holding the account

- Customer_Age: Demographic variable - Customer's Age in Years

- Gender: Demographic variable - M=Male, F=Female

- Dependent_count: Demographic variable - Number of dependents

- Education_Level: Demographic variable - Educational Qualification of the account holder (example: high school, college graduate, etc.)

- Marital_Status: Demographic variable - Married, Single, Divorced, Unknown

- Income_Category: Demographic variable - Annual Income Category of the account holder (<  40K, 40K - 60K,  60K− 80K,  80K− 120K, > $120K, Unknown)

- Card_Category: Product Variable - Type of Card (Blue, Silver, Gold, Platinum)

- Months_on_book: Period of relationship with bank

- Total_Relationship_Count: Total no. of products held by the customer

- Months_Inactive_12_mon: No. of months inactive in the last 12 months

- Contacts_Count_12_mon: No. of Contacts in the last 12 months

- Credit_Limit: Credit Limit on the Credit Card

- Total_Revolving_Bal: Total Revolving Balance on the Credit Card

- Avg_Open_To_Buy: Open to Buy Credit Line (Average of last 12 months)

- Total_Amt_Chng_Q4_Q1: Change in Transaction Amount (Q4 over Q1)

- Total_Trans_Amt: Total Transaction Amount (Last 12 months)

- Total_Trans_Ct: Total Transaction Count (Last 12 months)

- Total_Ct_Chng_Q4_Q1: Change in Transaction Count (Q4 over Q1)

- Avg_Utilization_Ratio: Average Card Utilization Ratio

## Target

Attrition_Flag: Internal event (customer activity) variable - if the account is closed then 1(Attrited Customer) else 0(Existing Customer)

# Exploring the Data

The report for the sales team begins here
"""

import seaborn as sns
import plotly.express as plx
import matplotlib.pyplot as plt

cat_features = data.select_dtypes(['object','category']).columns.to_list()

for cat in cat_features:
    fig = plx.pie(data[cat].value_counts(False), values=cat, names = data[cat].value_counts(False).index,title = cat,template='ggplot2')
    fig.show()

"""The customer gender is almost even, 30% college graduates with half being either Highschool graduates, unkown, or uneducated. The remaining 40% are either current college students,or grad students.

Almost half are married, 38% single, and the remaining 12 are divorced or unkown. 35% of customers make less than $40k per year which is near the poverty threshold. The rest are more evenly spaced out. 93% of customers choose the cheapest card option (likely the lowest interest rate) with a tiny portion choosing the more expensive cards
"""

fig = plx.box(data, color="Attrition_Flag", y="Total_Relationship_Count",title='Number of products held by customer', points="all")
fig.show()

"""Churned customers are likely to hold less credit cards than existing customers which is shown by a lower median . Is there a deal you provide that favors customers with multiple credit cards? (Like customers with spouses, families, or buisnesses that need additional cards)."""

fig = plx.box(data, color="Attrition_Flag", y="Months_Inactive_12_mon", points="all",title='Number of months with no transactions in the last year')
fig.show()

"""Churned customers tend to have slightly more inactive months, but the distribution is more concentrated from the 1-4 months inactive (though this may be from the small sample size)"""

fig = plx.histogram(data, x="Credit_Limit", color="Attrition_Flag",title='Credit limit on the credit card')
fig.show()

"""Churned customers have a lower credit limit, so perhaps increase the credit limit for these"""

fig = plx.box(data, color="Attrition_Flag", y="Total_Revolving_Bal", points="all",title='Total revolving balance on the credit card')
fig.show()

"""Churned customers have a much smaller revolving balance which, because they don't fully pay off their credit card balance, may signify that they have less disposable income than staying customers that know they can pay off their revolving balance"""

fig = plx.histogram(data, x="Total_Trans_Ct", color="Attrition_Flag",title='Number of transactions made in the last year')
fig.show()

"""Churned customers will have a lower amount of transactions, which makes sense as they're less involved with this company and will have a smaller transaction change over time as displayed bellow"""

fig = fig = plx.box(data, color="Attrition_Flag", y="Total_Ct_Chng_Q4_Q1", points="all",title='Change in transaction number over the last year (Q4 over Q1)')
fig.show()

plt.subplots(figsize=(15,8))
plt.title('Correlation between variables')
sns.heatmap(data.corr(),annot=True,cmap='YlGnBu')

"""**A lower Total Transaction change,revolving balance, and higher Number of contacts within the past year are most correlated with a churning customer**

The following features are the most correlated (> 0.75%)

- The months of being a customer with the bank(months on the book) and the Age are positive
- Credit Limit and Average Open To Buy Credit Line are also positive

The following are moderately correlated (30-75%)

- Total Transaction count and Total Relationship count are negative
- Credit Limit and Average Utilization Ratio are negative
Total Revolving balance and Average Utilization Ratio are positive
Average Open To Buy and Average Utilization Ration are negative
"""

# Checking the imbalance in the target variable: Attrition_Flag (Hidden Input)

fig = plx.pie(data, values=data["Attrition_Flag"].value_counts(), color=data["Attrition_Flag"].unique() ,
             color_discrete_map={0:"#1f2833", 1:"#66fcf1"},
             title='Imbalance in Target Feature', names=data["Attrition_Flag"].unique())
fig.show()

"""# Data Preprocessing"""

data_copy = data

data.info()

"""## Converting Categorical Features

If you are familiar with machine learning, you will probably have encountered categorical features in many datasets. These generally include different categories or levels associated with the observation, which are non-numerical and thus need to be converted so the computer can process them.
"""

data_cat = data[cat_features]
data_cat

a_map = {'Attrited Customer':1, 'Existing Customer':0}
data['Attrition_Flag'] = data['Attrition_Flag'].map(a_map)

g_map = {'M':0, 'F':1}
data['Gender'] = data['Gender'].map(g_map)

from sklearn.preprocessing import OrdinalEncoder

marital = OrdinalEncoder(categories=[['Unknown','Single','Married','Divorced']])
data['Marital_Status'] = marital.fit_transform(data_cat[['Marital_Status']])

edu = OrdinalEncoder(categories=[['Unknown', 'Uneducated', 'High School', 'College','Graduate',
                                  'Post-Graduate','Doctorate']])
data['Education_Level'] = edu.fit_transform(data_cat[['Education_Level']])

income = OrdinalEncoder(categories=[['Unknown','Less than $40K','$40K - $60K','$60K - $80K',
                                     '$80K - $120K','$120K +']])
data['Income_Category'] = income.fit_transform(data_cat[['Income_Category']])

card = OrdinalEncoder(categories=[['Blue', 'Silver','Gold','Platinum']])
data['Card_Category'] = card.fit_transform(data_cat[['Card_Category']])

data[cat_features].head()

"""## Scaling Continuous Features

Feature Scaling or Standardization: It is a step of Data Pre Processing that is applied to independent variables or features of data. It basically helps to normalize the data within a particular range. Sometimes, it also helps in speeding up the calculations in an algorithm.

**Why and Where to Apply Feature Scaling?**

The real-world dataset contains features that highly vary in magnitudes, units, and range. Normalization should be performed when the scale of a feature is irrelevant or misleading and not should Normalise when the scale is meaningful.
"""

cont = data.select_dtypes(['float64','int64','category']).columns.to_list()
data_cont = data[cont]
data_cont.head()

from sklearn.preprocessing import StandardScaler

credit = StandardScaler()
data['Credit_Limit'] = credit.fit_transform(data_cont[['Credit_Limit']])

revolv_bal = StandardScaler()
data['Total_Revolving_Bal'] = revolv_bal.fit_transform(data_cont[['Total_Revolving_Bal']])

avg_open = StandardScaler()
data['Avg_Open_To_Buy'] = avg_open.fit_transform(data_cont[['Avg_Open_To_Buy']])

trans = StandardScaler()
data['Total_Trans_Amt'] = trans.fit_transform(data_cont[['Total_Trans_Amt']])

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OrdinalEncoder

def preprocessCustomersPipeline(data):
    """Prepares the original customers data table in a form ready for the Deep Learning model, using
    all the transformations and edits we used above, and returns a ready dataset"""

    data = data.drop('Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1',1)
    data = data.drop('Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2', 1)
    data = data.drop('CLIENTNUM', 1)
    
    #Categorical Features
    a_map = {'Attrited Customer':1, 'Existing Customer':0}
    data['Attrition_Flag'] = data['Attrition_Flag'].map(a_map)
    g_map = {'M':0, 'F':1}
    data['Gender'] = data['Gender'].map(g_map)
    
    marital = OrdinalEncoder(categories=[['Unknown','Single','Married','Divorced']])
    data['Marital_Status'] = marital.fit_transform(data[['Marital_Status']])

    edu = OrdinalEncoder(categories=[['Unknown', 'Uneducated', 'High School', 'College','Graduate',
                                      'Post-Graduate','Doctorate']])
    data['Education_Level'] = edu.fit_transform(data[['Education_Level']])

    income = OrdinalEncoder(categories=[['Unknown','Less than $40K','$40K - $60K','$60K - $80K',
                                         '$80K - $120K','$120K +']])
    data['Income_Category'] = income.fit_transform(data[['Income_Category']])

    card = OrdinalEncoder(categories=[['Blue', 'Silver','Gold','Platinum']])
    data['Card_Category'] = card.fit_transform(data[['Card_Category']])
    
    #Numerical Features
    credit = StandardScaler()
    data['Credit_Limit'] = credit.fit_transform(data[['Credit_Limit']])
    revolv_bal = StandardScaler()
    data['Total_Revolving_Bal'] = revolv_bal.fit_transform(data[['Total_Revolving_Bal']])
    avg_open = StandardScaler()
    data['Avg_Open_To_Buy'] = avg_open.fit_transform(data[['Avg_Open_To_Buy']])
    trans = StandardScaler()
    data['Total_Trans_Amt'] = trans.fit_transform(data[['Total_Trans_Amt']])
    
    nums = ['Credit_Limit','Total_Revolving_Bal','Avg_Open_To_Buy','Total_Trans_Amt', 'Total_Trans_Ct']
    for n in nums:
        s = StandardScaler()
        data[n] = s.fit_transform(data[[n]])
    return data

"""## SMOTE | Over-Sampling

To correct the problem of unbalancing the classes of the data set, I will use the SMOTE method.


One approach to addressing imbalanced datasets is to oversample the minority class. The simplest approach involves duplicating examples in the minority class, although these examples don’t add any new information to the model. Instead, new examples can be synthesized from the existing examples. This is a type of data augmentation for the minority class and is referred to as the Synthetic Minority Oversampling Technique, or SMOTE for short.

SMOTE works by selecting examples that are close in the feature space, drawing a line between the examples in the feature space and drawing a new sample at a point along that line.

>SMOTE first selects a minority class instance a at random and finds its k nearest minority class neighbors. The synthetic instance is then created by choosing one of the k nearest neighbors b at random and connecting a and b to form a line segment in the feature space. The synthetic instances are generated as a convex combination of the two chosen instances a and b.


>The combination of SMOTE and under-sampling performs better than plain under-sampling.

SMOTE: Synthetic Minority Over-sampling Technique](https://arxiv.org/abs/1106.1813), 2011

![image.png](data:image/png;base64,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)
"""

data.shape

data.head()

# Importing packages for SMOTE
from imblearn.over_sampling import SMOTE
from imblearn.over_sampling import BorderlineSMOTE
from imblearn.under_sampling import RandomUnderSampler
import plotly.graph_objects as go
import plotly.figure_factory as ff

from imblearn.pipeline import Pipeline

from collections import Counter

from plotly.subplots import make_subplots

# Generate x and y sets
x = data.drop('Attrition_Flag', axis=1).values
y = data['Attrition_Flag']

# Splitting the dataset into training set and test set
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(x, data['Attrition_Flag'], test_size = 0.33, random_state=1234)

sm = SMOTE(sampling_strategy='auto', random_state=69)
x_sm, y_sm = sm.fit_resample(X_train, y_train)

print(Counter(y_train))
print(Counter(y_test))

fig = make_subplots(rows=1, cols=2, specs=[[{"type": "pie"}, {"type": "pie"}]])

fig.add_trace(
    go.Pie(labels=list(Counter(y_train).keys()), values=list(Counter(y_train).values()), name='Original data'),
    row=1, col=1
)

fig.add_trace(
    go.Pie(labels=list(Counter(y_sm).keys()), values=list(Counter(y_sm).values()), name='SMOTE data'),
    row=1, col=2
)

fig.update_traces(textposition='inside', hole=.4, hoverinfo="value+percent+name")
fig.update_layout(
    title_text="Class distribution",
    # Add annotations in the center of the donut pies.
    annotations=[dict(text='Original', x=0.16, y=0.5, font_size=12, showarrow=False),
                 dict(text='SMOTE', x=0.82, y=0.5, font_size=12, showarrow=False)])
fig.show()

over = BorderlineSMOTE(sampling_strategy=0.3)
under = RandomUnderSampler(sampling_strategy=0.6)

steps = [('o', over), ('u', under)]

pipeline = Pipeline(steps=steps)

# transform the dataset
x_sm_us, y_sm_us = pipeline.fit_resample(X_train, y_train)

list(Counter(y_train).keys())

fig = make_subplots(rows=1, cols=2, specs=[[{"type": "pie"}, {"type": "pie"}]])

fig.add_trace(
    go.Pie(labels=list(Counter(y_train).keys()), values=list(Counter(y_train).values()), name='Original Data'),
    row=1, col=1
)

fig.add_trace(
    go.Pie(labels=list(Counter(y_sm_us).keys()), values=list(Counter(y_sm_us).values()), name='SMOTE and US data'),
    row=1, col=2
)

fig.update_traces(textposition='inside', hole=.4, hoverinfo="percent+name+value")
fig.update_layout(
    title_text="Class distribution",
    # Add annotations in the center of the donut pies.
    annotations=[dict(text='Original', x=0.16, y=0.5, font_size=12, showarrow=False),
                 dict(text='SMOTE and UnderSample', x=0.9, y=0.5, font_size=12, showarrow=False)])
fig.show()

"""Model Testing no SMOTE"""

# XGBoost model
import xgboost as xgb
from sklearn.metrics import classification_report, f1_score, confusion_matrix, accuracy_score, roc_auc_score, roc_curve,plot_confusion_matrix

xgb_model = xgb.XGBClassifier(random_state=69, use_label_encoder=False, n_jobs=-1)

xgb_model.fit(X_train, y_train)

# XGBoost Score on the test data

xgb_model.score(X_test, y_test)

print('F1-Score: ', f1_score(y_test, xgb_model.predict(X_test)))

"""Model Testing with SMOTE"""

xgb_model = xgb.XGBClassifier(random_state=69, use_label_encoder=False, n_jobs=-1)

xgb_model.fit(x_sm, y_sm)

# XGBoost Score on the test data

xgb_model.score(X_test, y_test)

print('F1-Score: ', f1_score(y_test, xgb_model.predict(X_test)))

"""Model Testing with BorderlineSmote"""

xgb_model = xgb.XGBClassifier(random_state=69, use_label_encoder=False, n_jobs=-1)

xgb_model.fit(x_sm_us, y_sm_us)

# XGBoost Score on the test data

xgb_model.score(X_test, y_test)

print('F1-Score: ', f1_score(y_test, xgb_model.predict(X_test)))

"""As you can see, the highest F1 score is when we're running a model with SMOTE. so in we will running a model with SMOTE

## ML Model Shortlisting
Testing out a couple Machine Learning models before we use the Deep Neural Net

For identifying the Customer churn, we are going to use Extreme Gradient Boosting technique (XGBoost)

XGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Hadoop, SGE, MPI) and can solve problems beyond billions of examples.

Read more about the same: https://xgboost.readthedocs.io/en/latest/
"""

xgb_model = xgb.XGBClassifier(random_state=69, use_label_encoder=False, n_jobs=-1)

xgb_model.fit(x_sm, y_sm)

# XGBoost Score on the test data

xgb_model.score(X_test, y_test)

print(classification_report(y_test, xgb_model.predict(X_test)))

# pred = xgb_model.predict(X_test)
# pred = np.argmax(pred,axis = 1)

from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
import xgboost
from sklearn.metrics import accuracy_score

rf = RandomForestClassifier()
knn = KNeighborsClassifier(n_neighbors=5)
svc = SVC()
xgb = xgboost.XGBClassifier(use_label_encoder=False)

ml_models = [rf,knn,svc, xgb]
for ml in ml_models:
    ml.fit(x_sm, y_sm)
    y_pred = ml.predict(X_test)
    print(accuracy_score(y_pred,y_test))
    print('F1-Score: ', f1_score (y_test, y_pred))

"""as you can see, the best f1 score result is from xgboost"""

#after running
dt=xgboost.XGBClassifier(criterion='entropy',max_depth=11)
dt.fit(X_train, y_train)

dt_pred=dt.predict(X_test)

print('Report: ',classification_report(y_test, dt_pred))

#after running
dt=xgboost.XGBClassifier(criterion='entropy',max_depth=11)
dt.fit(x_sm, y_sm)

dt_pred=dt.predict(X_test)

print('Report: ',classification_report(y_test, dt_pred))

# Creating the Confusion Matrix (Hidden Input)

cfm = confusion_matrix(y_test, dt_pred)

TP = cfm[0][0]
FN = cfm[0][1]
FP = cfm[1][0]
TN = cfm[1][1]


fig, ax = plt.subplots(figsize=(16, 8))
plt.title("Confusion Matrix and Corresponding Accuracy, Precision and Recall", size=20, pad=20)
plot_confusion_matrix(xgb_model, X_test, y_test, cmap='plasma', ax=ax)
plt.show()

print("*" * 30)
print("Accuracy :", (TP+TN)/(TP+TN+FP+FN))
print("Precision :", (TP)/(TP+FP))
print("Recall :", (TP)/(TP+FN))
print("*" * 30)

"""## The Neural Network

Since this is a standard binary classification problem, we'll use a shallow feedforward neural network with 19 input neurons and 2 output neurons

A neural network is built using various hidden layers. Now that we know the computations that occur in a particular layer, let us understand how the whole neural network computes the output for a given input X. These can also be called the forward-propagation equations.


![image.png](data:image/png;base64,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9JnA12tT954+rgTplr7jUlXLfHFZeUbnZGyZA2dEfzPP8sxolVmzgzGXDns+AnZ6TrqL7T1SOwhBRseMJRpefgbUkQIq33fU9zig0Unv/Uy7K4vGhzN9Q5yjbJxVguox8ak3crwr+/yubeFkcEgtR1OuilrPnWk/eqDPR5ZoN1pqlRhkYPn4QgSLEy1rMA50tJTPtnXVc4hOth9x7glt1ubYV7hnlkFkC7KL5zk+QtSzcMPzOApYjzjFJSlO4+pyhhOFifTUs1fPPCHJ6tn5570YMTKTUg0qXV/pJNT2mWf6jy1HHKNJOGtnXC0g0gz7KHrq3GGyz9p95vMwzThQ+hQDFGxXrzxm7T7DicIHW2HUKpHLHTL0Vj+XXI/7ZTNLPKX0M3WWdPjDGyHIIWCO7JaLxkr1Mo73UzErA+3t9ZVsxJXz1auyM5wo9svmkgXfCSRaMV3No9a/pdditMDobBSN9bITeWnHP7gxrRp6WUCJR5kDwvd4lXS+f9fKajYxwHHJqczW/f72NZ/OcqJKvmpZpgL947VWLvFwjAApD55DXNxnAivCSDQ1iGvk4FZqBDRhGZNsITgyXjOON9v2Oz8HF/SLtjXxxSmzDUNwItMq5wRjRLtXZPxnOVHYETDififXxBGmjy/l3pqc4sw5Anw8sJsYqAk/2x0En3EMs+2+8/Ol8yu131uK4iTL52vfz3YmZzlRjTvZJn6AA43xHWfqYgImYAJvSeBsJ/qWkNxpEzABE2gRsBNtkfF1EzABE0gQYAuCfUkXEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzAB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A/7y/+0IM7IYTMAE/kJAP275T3f+gubPC8rWs1se9VZ81QRM4LEE+JGHbPQd9yrPGBTtG+NMXUzABEygSkA/GB39Q1b15Te/yH7xzN/C3twcd88ETOAIAlqyknW5fCfAD0lk6d7q+M7En0zABBoE9Au0s9HvgMhAnYV+5+FPJmACHQI4T7IuZ6PfICkL9S/yHdH4lgmYwI8E5Dje7T+KfrRi/zcFFC/j97N0CybwcQTIRD99CcvWhv+k6eOkb4NNYB0B/nb0U50I/+LpP/dapyW3ZAIfS4CM9NOWs/yVwqcGj48Vug03ARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARMwARP4cAL/fb1ef3wdv+5g8Y/QDu39c0dbrrqfgMd1jqF5zfHa8/TjWP/2er3+9Xq9/v56vf62h8xXG7RDm3aiO2HurO5xnQNoXnO89jz9ONYY9FOHCE7xl9frRZb6+5eD/PnLYbaq0aadaIvOOdfPHlcCsVY06ERaoR+6zpnvHNyP13saPIPYiJf6QD81H3StdaZNz4O/0hmxfjuf0zMIAeA8MUqFZTt1mABMnFqxeGpUzr129riyREMr6KMscpg1h4JTQktRY2X9M76PeGEfzvPfX/3l+6h4HtQJjVi/nc9pGYSouVcrLPuVRdQmjcVTo3butTPHtacV7kkrre0i7l9dWrzKfkn7dqIlmfz3FuuejsQdrdzO57QM0vKMpXutEJUx6D+Vm7RZyzoqj/rSQQTOHFc00Bpv6ajndOjrEYWMBp1mSotXWVeTuWeP6ngeiMSP5xZraeVQn6NlkSL7lnPpxUcGcb9WMJT310T6CeLBxhH/0rHwfVSnxVvLyFb9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cM6wj6KkzkyQzPTpSc/AamYOYHvk+wkZ/tFOFE2j0162GwPX7HbBcr3G/bIZASjlnqmzvPMf2CATXE40u+WisVK9jOP9QLR/moyeZwNf5Nub+E9herQThZO0WmPGdotWZJevgqM3p1PZ/btYLzuRazB8bZ6AVg0zk1WRHWF6vNrMFaDaT9TvRL4wfno5w4kquatlmRqny7UclyAMPI6RDpcHz7HM5T4TWBFAkaJm5NNFdKV9CBj2jEm2EBypM+N4s22/+3PoF22TgUrTTM6MrnGezA9N6lif60/N+M9womiWMYn7nVwTa8bs8lLurUkAM+do4OUGfUgHEA9Cmi1blqmz73i35xWQWprvrcziL/Kt+lzvtfFuvNTfM5yo3kVAw89woGG+P5Gp7PXZBEzgAwic6UQ/AKdNNAET+DQCdqKfNuK21wRMYCmB7N8nL32pGzMBEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABEzABE0gS+Nvr9fpH8tknPfb31+vF4WICpxP47+v1+uPr+HXH25m4aofzP3e05arbCOBEfruJEz1bVwQPbP9pGzrXMoHtBBDev76iOELcU5QN0Kad6B6S83Vh//vXWM7XXl/jCl0RyGHwiZn4+hF0i2kCo+jN5Pzl9XqRpSJQnv95sHSyE03jX/agxmVZgzsbukpX//7SKbp1MYFTCPTETjaJ84yCJMpThyU7GWytcN+ZaI3MMdcIagS4vSuJlb27UldsJXC4mMBmAjg+ssdMaYkd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)

1. The first equation calculates the intermediate output Z[1] of the first hidden layer.
2. The second equation calculates the final output A[1] of the first hidden layer.
3. The third equation calculates the intermediate output Z[2] of the output layer.
4. The fourth equation calculates the final output A[2] of the output layer which is also the final output of the whole neural network.
"""

import tensorflow as tf
from tensorflow import keras

model = keras.models.Sequential([
    keras.layers.Dense(19,input_shape=X_train.shape[1:]),
    keras.layers.BatchNormalization(),
    keras.layers.Dense(7, activation="elu", kernel_initializer="LecunNormal"),
    keras.layers.Dropout(0.3),
    keras.layers.Dense(2, activation="relu",  kernel_initializer="he_normal")
])

model.compile(loss="sparse_categorical_crossentropy", 
              optimizer=keras.optimizers.Nadam(learning_rate=0.001),metrics=["accuracy"])

history = model.fit(X_train, y_train, epochs=50, validation_data=(X_test, y_test))

import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

def plot_learning_curves(loss, val_loss):
    plt.plot(np.arange(len(loss)) + 0.5, loss, "b.-", label="Training loss")
    plt.plot(np.arange(len(val_loss)) + 1, val_loss, "r.-", label="Validation loss")
    plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))
    plt.axis([1, 50, 0.25, 2])
    plt.legend(fontsize=14)
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.grid(True)

plot_learning_curves(history.history["loss"], history.history["val_loss"])
plt.show()

from sklearn.base import BaseEstimator, ClassifierMixin

#Translate the Tensorflow model into a Scikit-Learn model, so it can be used with the ensemble voting classifier
class NN(BaseEstimator, ClassifierMixin):
    def __init__(self, demo_param='demo'):
         self.demo_param = demo_param

    def fit(self, X, y):
        return self

    def predict(self, X):
        return model.predict(X)
    
    def predict_proba (self, X):
        return model.predict(X)

"""## Model Assemble
Ensembling our ML models together to get the highest possible accuracy. It's interesting how the Random Forest and XGBoost Classifiers got a 10% higher accuracy than the shallow neural network, for we did not need to tweak any of its hyperparameters. Perhaps Ockham's Razor is clearly shown here?

**Occam’s razor suggests that in machine learning, we should prefer simpler models with fewer coefficients over complex models like ensembles.
"""

from sklearn.ensemble import VotingClassifier
from sklearn.metrics import classification_report, f1_score, confusion_matrix, accuracy_score

rf = RandomForestClassifier()
knn = KNeighborsClassifier(n_neighbors=5)
svc = SVC(probability=True)
xgb = xgboost.XGBClassifier(use_label_encoder=False)
nn = NN()

voting_clf = VotingClassifier(estimators=[('rf',rf), ('knn', knn), ('svc',svc),('xgb',xgb), ('nn', nn)], voting="soft", weights=[1,0.2,0.2,1,0.6])
voting_clf.fit(X_train, y_train)
pred = voting_clf.predict(X_test)
print('Accucracy :', accuracy_score(pred, y_test))

print(classification_report(y_test, pred))

# Creating the Confusion Matrix (Hidden Input)

cfm = confusion_matrix(y_test, pred)

TP = cfm[0][0]
FN = cfm[0][1]
FP = cfm[1][0]
TN = cfm[1][1]


fig, ax = plt.subplots(figsize=(16, 8))
plt.title("Confusion Matrix and Corresponding Accuracy, Precision and Recall", size=20, pad=20)
plot_confusion_matrix(xgb_model, X_test, y_test, cmap='plasma', ax=ax)
plt.show()

print("*" * 30)
print("Accuracy :", (TP+TN)/(TP+TN+FP+FN))
print("Precision :", (TP)/(TP+FP))
print("Recall :", (TP)/(TP+FN))
print("*" * 30)

"""## Metrics Evaluation 

- Confusion Matrix is a tool to determine the performance of classifier. It contains information about actual and predicted classifications. The below table shows confusion matrix of two-class, churned customers and non-churned customers classifier.

- True Positive (TP) is the number of correct predictions that an example is positive which means positive class correctly identified as positive. Example: Given class is churned and the classifier has been correctly predicted it as churned.

- False Negative (FN) is the number of incorrect predictions that an example is negative which means positive class incorrectly identified as negative. Example: Given class is churned however, the classifier has been incorrectly predicted it as non-churned.

- False positive (FP) is the number of incorrect predictions that an example is positive which means negative class incorrectly identified as positive. Example: Given class is non-churned however, the classifier has been incorrectly predicted it as churned.

- True Negative (TN) is the number of correct predictions that an example is negative which means negative class correctly identified as negative. Example: Given class is not churned and the classifier has been correctly predicted it as not negative.

- Recall

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAABPCAYAAADY1zh1AAALS0lEQVR4Ae1dd6gUPxd9oqCCKHZBsaCi2FDsDQv2giB2/1FR7L2gggr2XlFRQUFRsWBFFLvYsSEKduyKvWLX/Dj5uCE7O/Pe7rfl7cw7gSHZmzLJSU4muSmbpmiIABEIHAJpgSsRC0QEiIAisdkIiEAAESCxA1ipLBIRILHZBohAABEgsQNYqSwSESCx2QaIQAARILEDWKksEhEgsdkGiEAAESCxA1ipLBIRILHZBohAABEgsQNYqSwSESCx2QaIQAARILEDWKksEhEgsdkGiEAAESCxA1ipLBIRILHZBohAABEgsQNYqSwSESCx2QaIQAARILEDWKksEhEgsdkGiEAAESCxA1ipLBIRILHZBohAABEgsQNYqSwSESCx2QaIQAARILEDWKnxKtKcOXPUjBkzMnyePn2qX7l+/Xo1c+ZM86xcuVIdPHgwXtlhOlEgQGJHAVZWC1qhQgWVlpaW4XP8+HENTbVq1VzDlilTRp04cSKrwZep5SWxMxX+1H7579+/lf1UrFhRE/f169fq169f5pFSCLHF7/bt26pTp046TvHixSUY7SQgQGInAeSgvEKI/fHjR9ciCbGdnj169NDkPnDggNOLvxOEAImdIGCDmGzlypU1QaMl9qJFi3S8ZcuWBRGWlCwTiZ2S1ZKamZIvcrTEHjx4sCY2FWnJq9csR2wocaZNm6Z2795tUD516pSWTZ8+3cjoCEegevXqUX+xr127prJly6YKFy6sMDenSQ4CcSM2iGIvdcC9atUqtW/fvuSUJMK3lCtXTjfORo0amRi9evXSsqJFixoZHeEI1KxZMyJi9+3bVw0dOlS1atVKh4dmfdu2beEJUpIwBOJG7Fy5cplKdC6RQOny5s2bhBUi0oQ/fPhg8jhq1CgTTZZ12rRpY2R0hCNQp06diIhdqFAhhTpv27atJvj9+/fDE6MkoQjEhdhXrlwxhMGaJXpsaEKzZ89u5EOGDEloQSJJ/MiRIyY/mzZt0lFssk+ePDmSZLJsmPr160dE7CwLUAoVPC7EXrt2rSHM6tWrTfGwE0m+3nXr1jVy2/Hw4UOFjuH9+/e2OMz97t07de7cOSW7nJwBsHZ69uxZ9f37d+P19u1b44ZjwYIFJj83btzQfseOHTOyHTt2hITnj1AEMH1BfUarPAtNhb+SgUBciD1w4EBDjuvXr5t8nz9/3sg7d+5s5HDMmjVL5c+f3/ijwXTv3l39/fs3JBzm7rLMIp1Eu3btTBh0CAMGDAhJZ+TIkUrmzb179zZhu3TposPlyZPHyObPn2/ipjdkfPHihXr27JnnA/+gmyZNmmisSOzUr+m4ELtWrVqGHHaRQVQho/017Nixo5FjHoavuYSzh+xr1qwxcvEX++vXr/pVjRs39gyDsAsXLjRZclOcSR4LFixowjkdnz59CplWSB5su0GDBs5ogfvdrFkzjbUXsatWrar9A1dwHxYoZmL/+fPHEAsKNGhDMb/OnTu3kY8ePdpAA7cQAocExFSpUkXLmzZtqkV37twx4erVq6euXr2q5UePHlV9+vTR7tmzZ5sw48ePV9++fVN79+5VxYoVM3LZx2zPpW3FWdmyZXXYFi1aSFbCbAzbS5Qoke6DJbSgG2CEuiOxU7+mYyb2xYsXDYmEsGKD6DZ5sY4pCrWePXsqfAkxvIWyTeKMHTtWo4YOQmSXL18OQ/Lfv3+GwFDq2AbElbjSCN0UZ5i3S7gJEybYSdDtgYCtw3ALkpG/WxzK4o9AzMTGWrWQA3PfcePGqQIFChiZvRFky5YtRi5xbBtzYDGlSpXSYTHMdzPYaCJxly5dGhKkZcuW2q98+fJG7qY4O3z4sElj69atJmyqODAKkGfdunVqw4YNYc/+/fv1ySngYT+XLl1SUEw6Hy/lY6qUmfmIDwIxE7tfv36GHA8ePNC5OnTokJHhdI+Y4cOHG3n79u31lxpfSiiwMPQW8/LlSxNuxIgRIg6xZf8xyA0lnZhHjx6ZuJg/i3FTnNlDefv9EkdsaIMxB3c+6MDkkbDxtKXjSpaN6Ubp0qXDHnSumCI5nw4dOuhpEaZG9tO/f3/TIUnHJDY7qHi2EO+0Yia27B/GENs22KSABglbTNeuXbUsb968InK17XXxMWPGuIbBnFoavE1KNCqRz5s3z8R1U5xBU4+w+fLlM+Gcjp8/f5r0JF2njY0biTBCBtgol00ecYNcTsLhN8joRlKQ15n/oP1ORgeViPqOZ5oxEfvHjx+mkWApxDayNIJGc/fuXe2F+bM0Iue8Gfu1ZckItoSrVKmSevXqlfry5YvatWuXypkzp04Ly2USBqOG58+fK3QCIoONeTWMl+KsZMmSOjyIkJ6BbiC9B+QPgsEw3Tl0x28M6+1hvrgxDXCbHuCrbHdKtls6JKeNXX9uHRT2p7t1ULaC1K7zZLlTvb5jIvaZM2cMkTC3ts2gQYOMn8xf9+zZY2RuFYADA2LsJTQ7rMzD7Xfb/s2bNzfvkE0vboozKHkknteoQPJC218IuHVOkGHKJp2SbUMP5NZBYbOV3SnZ7lRHJCZiQ2kl5Ni8eXNIWZcvX278pk6davzmzp2rT/pIPLG7detmwsBx8uRJVbt2bZMGwmHZ6/Tp0ybcxIkTQ/zRmSxevFjLbMXZkiVLtCxHjhzq3r17Oj46EXm3bC81CfvQ4af7ybCSIgeGnHeqYTVEzM6dO9WUKVOUvZtR/GBjMxT8t2/fbovpVkrFRGwgiC+f1xJHen6PHz9WGI6DaLh+x8s8efJEXbhwQQ8R3cJ8/vxZp2NvH8UyViQG697pvTuSNFIljBxkkc7Ky5Z1fdGNOMMl436ySZMmmU7V+X5Z7gSu9ukwe9lUMAehEd/ehCR+Wd2OmdhZHcBUKb99Nxncco0RdANyBxlsMUJs8Uvm/WRCbAyB5f1iS/5g28SGQsy53ZjEttEKdZPYoXgE5pcQWzboOAsmxHbKo72fDDsC8dWM5ty9EDujOELsYcOG6XdgedI2JLaNRqibxA7FIzC/5OBMtMSW/QGR3k8mxI7mIoVoiY1VEWjBsUxql4fE9m6uJLY3Nr72kQMZNhHsAnl9saO9n0yI7VSe2u9yuqMlNsogylgoTMWQ2IJEuE1ih2MSCEmy7ieLhdjoRHBmf+PGjeaxlaAyFJfOCQpC3J8GhSoMTgxSeebeXElsd1x8L03k/WQ4ZosvPnbz4Y8AQC5s9sFmIixR4lAOtgV7GfliI57zsc8WOIktF3fIkhiJ7YVwHJa7vJOmT2YikMj7yVq3bq1w0AZn0GVID2VdjRo1VMOGDbUfliG9jBAbN+9AGy+P7DGQeE5iQy4bl27evMkvtgDlYvOL7QJKEETJup8M11Xhq4vtvpEaITaupUrPuBFbvtLYRixurmOHo0hih2MSCEmy7icTYme0dGWDGguxkQ72lKMzWbFihbZJbBvd/7lJ7HBMAiGRQziieHIWSobQTnm0vzOD2PhHERBbOi8SO7zWSOxwTAIhSdb9ZKIVT+YXGxVk35tHYoc3WRI7HJNASFL5fjI5vPP/zLGlcm7duqWKFCmiv9xu+8glXFa1SewA17zX4Rwpckb+Ei4RdiTvxnn/SA/0JCKPfk6TxPZz7THvRMADARLbAxiKiYCfESCx/Vx7zDsR8ECAxPYAhmIi4GcESGw/1x7zTgQ8ECCxPYChmAj4GQES28+1x7wTAQ8ESGwPYCgmAn5GgMT2c+0x70TAAwES2wMYiomAnxEgsf1ce8w7EfBAgMT2AIZiIuBnBEhsP9ce804EPBAgsT2AoZgI+BkBEtvPtce8EwEPBEhsD2AoJgJ+RoDE9nPtMe9EwAMBEtsDGIqJgJ8RILH9XHvMOxHwQOA/e1VAuZERR4QAAAAASUVORK5CYII=)

The above equation can be explained by saying, from all the positive classes, how many we predicted correctly.
Recall should be high as possible.
Precision

- Precision 

![image.png](data:image/png;base64,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)

The above equation can be explained by saying, from all the classes we have predicted as positive, how many are actually positive.
Precision should be high as possible.

- Accuracy is From all the classes (positive and negative), how many of them we have predicted correctly. In this case, it will be 4/7.
Accuracy should be high as possible.

- F1-score

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWYAAABhCAYAAADlVAsaAAAX7ElEQVR4Ae2dBZQcxRaGycNdg8PB3d0dQnB3d3cL7oGgwQNJILg7hOAW3J2gwd2DQ7/z1Xn/vLtNz2Y2yez2DP89Z7a7y7rqr96/q2/dujVSZjECRsAIGIFSITBSqWrjyhgBI2AEjEBmYvZDYASMgBEoGQIm5pJ1iKtjBIyAETAx+xkwAkbACJQMARNzyTrE1TECRsAImJj9DBgBI2AESoaAiblkHeLqGAEjYARMzH4GjIARMAIlQ8DEXLIOcXWMgBEwAiZmPwNGwAgYgZIhYGIuWYe4OkbACBgBE7OfASNgBIxAyRAwMZesQ1wdI2AEjICJ2c+AETACRqBkCJiYS9Yhro4RMAJGwMTsZ8AIGAEjUDIETMwl6xBXxwgYASNgYvYzYASMgBEoGQIm5pJ1iKtjBIyAETAx+xkwAkbACJQMARNzyTrE1TECRsAImJj9DBgBI2AESoaAiblkHeLqGAEjYARMzH4GjIARMAIlQ8DEXLIOcXWMgBEwAiZmPwNGwAgYgZIhYGIuWYe4OkbACBgBE7OfASNgBIxAyRAwMZesQ1wdI2AEjICJ2c+AETACRqBkCJiYS9Yhro4RMAJGwMTsZ8AIGAEjUDIETMwl6xBXxwgYASNgYvYzYARaQWDbbbfNxh577FZSlCPq888/z9Zcc81s4403rlRos802y2aaaabKdTyZfvrps/POOy8Gler8u+++a1N9fvrppzalL3tiE3PZe8j1G6EIDBkyJNtrr72yWWaZJRtjjDGy+eefPzvzzDP/cY8ddtghGzBgQHbEEUdkSy65ZPbNN99kU089dYt0hxxySLbQQgul38ILL5ytttpqWc+ePVukaa+Lr776KhtppJGys88+u3LLRRZZJFtjjTUq119//XW24447putRRhklu/DCC1Mb8wS99NJLV9pE+yD822+/vVJOvU8GDhyY2tK9e/eabrXVVlul9LSvWcTE3Cw96XbUhADkOeecc6Z/ZIhMv/PPP7+S/8cff8wWX3zxFAe5QeKkm2666bJLLrmkkm7ddddN4Ycffnh21FFHZbPPPnu6nnvuuStp2uukFmKmjWONNVY25phjZqOOOmq20korpfquvvrqlWr+/PPPKYw2H3vssRkvH2F04oknVtLV8+Szzz7Lll122ezKK6+s6TYQ+AYbbFBT2kZJZGJulJ5yPUcIAvnR4a+//ppGwhBBXk455ZREYBDTAQcckI/ORMwxAtUH6fv16xeD635eCzGrEl27dk117Ny5cxoxK5yjiJm2RZlssslSHr4cLPVHwMRcf4x9h5IjACnPNttslVoyYmakDMESt8ACC6RzRsLPPvtsJV0RMV966aUp7ZFHHllJx8mNN96Ybbnlltlcc82Vrbfeetldd93VIp6Le++9N9twww1Tmo022ii74oorKmn69++fbbHFFtliiy2WLb/88ulF8emnn1biayHmPn36ZKOPPno2+eSTZyOPPHK24oorprrG0WY1YqY94PHqq6+me/KiIt9zzz2Xrb/++hnqD8WRoEePHtlaa62VcKTeH3zwQaWuOjn33HOT+gc10Pbbb589+uijKeqVV15Jo3niJW+++WbGSw/VCqqlqDKad955U/o//vhDydPx1FNPzcARzKnLxRdf3CKe8ldZZZUUduihh2aLLrpoUv3QVx0tJuaO7gHfv8MRmGCCCRK5xIpss8022dNPP53IAD3tl19+mQgtpikiZsgAAoNIJVIHnHDCCRnqBOL53X333UqSRtgK57jrrrumNO+8806qB2HU6Ywzzkh6b1QRELSkFmJmgnC77bZLWf7zn/9kt912W3bttddmfBlIqhFzt27dUn2+/fbblHTvvfdO15SjeksPveqqq6ZJR4gPwiN+0kknTaNx3WfnnXeu5AMzCHKOOeZI0c8//3yKU71o21RTTZXCbrnllmyTTTZJLxaVpa+U3377TUHZEkssUSlf9eMYX5h8PREmVVVM99BDD1XK6ogTE3NHoO57lgaB3r17p3/Oq6++urBOkCE62SIRMUMye+yxR7b22munsiBiyeOPP57Com7677//TmFdunRJyZiQhLjiRB0REKeEUWSU448/PpXxxRdfpOBaiDnmh4R69eoVg9J5ETE/8sgj2XjjjZdGpcogYl5wwQUVlI6nn356qhcvFAkvIO5HnZE777wzXUPIUYRRnpgZSZP/nnvuickr53lipl2k79u3byUNJ+uss06ysPnhhx9SuIiZyUPJyy+/nPLuvvvuCuqQo4m5Q2D3TcuAwEsvvZQmw/jHHhYRMUMC+hEWBYsP4h577LHs7bffrvwYHULGyIsvvpjSYCVRi3z00UfpU55y+cRH2krM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)

It is difficult to compare two models with low precision and high recall or vice versa. So to make them comparable, we use F-Score. F-score helps to measure Recall and Precision at the same time. It uses Harmonic Mean in place of Arithmetic Mean by punishing the extreme values more.

# Conclusion:

- The highest accuracy achieved was 96% and the highest f1-score is 90% which went way above our manager's expectations. However, we have raised the bar, and in further problems, he will be expecting more
- Total Transaction change,revolving balance,and Number of contacts within the past year are most correlated with a churning customer
"""